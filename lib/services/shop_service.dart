import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/shop.dart';
import '../models/product.dart';
import 'dart:math';

class ShopService {
  final SupabaseClient _supabase = Supabase.instance.client;

  Future<Shop> createShop(Shop shop) async {
    try {
      // For INSERT, exclude id and created_at (auto-generated by database)
      final shopData = {
        'owner_id': shop.ownerId,
        'name': shop.name,
        'address': shop.address,
        'pincode': shop.pincode,
        'radius_km': shop.radiusKm,
        'open_status': shop.openStatus,
      };

      final response = await _supabase
          .from('shops')
          .insert(shopData)
          .select()
          .single();

      return Shop.fromJson(response);
    } catch (e) {
      rethrow;
    }
  }

  Future<List<Shop>> getShopsByPincode(String pincode) async {
    try {
      print('DEBUG ShopService: Querying shops for pincode: $pincode');
      
      // First, let's try to get all shops to see if the table exists and has data
      final allShopsResponse = await _supabase
          .from('shops')
          .select()
          .limit(5);
      print('DEBUG ShopService: All shops sample: $allShopsResponse');
      
      final response = await _supabase
          .from('shops')
          .select()
          .eq('pincode', pincode);
          // Temporarily remove open_status filter to see if that's the issue
          // .eq('open_status', true);

      print('DEBUG ShopService: Raw response for pincode $pincode: $response');
      final shops = (response as List)
          .map((shop) => Shop.fromJson(shop))
          .toList();
      print('DEBUG ShopService: Parsed ${shops.length} shops');
      return shops;
    } catch (e) {
      print('DEBUG ShopService: Error in getShopsByPincode: $e');
      rethrow;
    }
  }

  Future<Shop?> getShopByOwnerId(String ownerId) async {
    try {
      final response = await _supabase
          .from('shops')
          .select()
          .eq('owner_id', ownerId)
          .maybeSingle();

      return response != null ? Shop.fromJson(response) : null;
    } catch (e) {
      rethrow;
    }
  }

  Future<Shop> updateShop(Shop shop) async {
    try {
      final response = await _supabase
          .from('shops')
          .update(shop.toJson())
          .eq('id', shop.id)
          .select()
          .single();

      return Shop.fromJson(response);
    } catch (e) {
      rethrow;
    }
  }

  Future<void> deleteShop(String shopId) async {
    try {
      await _supabase.from('shops').delete().eq('id', shopId);
    } catch (e) {
      rethrow;
    }
  }

  Future<List<Shop>> getAllShops() async {
    try {
      final response = await _supabase.from('shops').select();

      return (response as List)
          .map((shop) => Shop.fromJson(shop))
          .toList();
    } catch (e) {
      rethrow;
    }
  }

  // Product management
  Future<Product> addProduct(Product product) async {
    try {
      // For INSERT, exclude id and created_at (auto-generated by database)
      final productData = {
        'shop_id': product.shopId,
        'name': product.name,
        'category': product.category,
        'price': product.price,
        'stock': product.stock,
        'image_url': product.imageUrl,
      };

      final response = await _supabase
          .from('products')
          .insert(productData)
          .select()
          .single();

      return Product.fromJson(response);
    } catch (e) {
      rethrow;
    }
  }

  Future<List<Product>> getProductsByShop(String shopId) async {
    try {
      final response = await _supabase
          .from('products')
          .select()
          .eq('shop_id', shopId);

      return (response as List)
          .map((product) => Product.fromJson(product))
          .toList();
    } catch (e) {
      rethrow;
    }
  }

  Future<Product> updateProduct(Product product) async {
    try {
      final response = await _supabase
          .from('products')
          .update(product.toJson())
          .eq('id', product.id)
          .select()
          .single();

      return Product.fromJson(response);
    } catch (e) {
      rethrow;
    }
  }

  Future<void> deleteProduct(String productId) async {
    try {
      await _supabase.from('products').delete().eq('id', productId);
    } catch (e) {
      rethrow;
    }
  }

  // Search shops by product name
  Future<List<Shop>> searchShopsByProduct(String productName, String pincode) async {
    try {
      print('DEBUG ShopService: Searching shops with product: $productName in pincode: $pincode');
      
      // Query to find shops that have products matching the search term
      // and are in the specified pincode
      final response = await _supabase
          .from('shops')
          .select('''
            *,
            products!inner(name, category)
          ''')
          .eq('pincode', pincode)
          .ilike('products.name', '%$productName%');

      print('DEBUG ShopService: Raw search response: $response');
      
      // Extract unique shops from the response
      final Map<String, Shop> uniqueShops = {};
      
      for (final item in response as List) {
        final shopData = Map<String, dynamic>.from(item);
        // Remove the products array from shop data for clean parsing
        shopData.remove('products');
        
        final shop = Shop.fromJson(shopData);
        uniqueShops[shop.id] = shop;
      }
      
      final shops = uniqueShops.values.toList();
      print('DEBUG ShopService: Found ${shops.length} unique shops with product: $productName');
      return shops;
    } catch (e) {
      print('DEBUG ShopService: Error in searchShopsByProduct: $e');
      rethrow;
    }
  }

  // Search shops by product name and location
  Future<List<Shop>> searchShopsByProductAndLocation({
    required String productName,
    required double latitude,
    required double longitude,
    required double radiusKm,
  }) async {
    try {
      print('DEBUG ShopService: Searching shops with product: $productName near location ($latitude, $longitude) within ${radiusKm}km');
      
      // Query to find shops that have products matching the search term
      // and are within the specified radius
      final response = await _supabase
          .from('shops')
          .select('''
            *,
            products!inner(name, category)
          ''')
          .not('latitude', 'is', null)
          .not('longitude', 'is', null)
          .ilike('products.name', '%$productName%');

      print('DEBUG ShopService: Raw location search response: $response');
      
      // Extract unique shops and filter by distance
      final Map<String, Shop> uniqueShops = {};
      
      for (final item in response as List) {
        final shopData = Map<String, dynamic>.from(item);
        // Remove the products array from shop data for clean parsing
        shopData.remove('products');
        
        final shop = Shop.fromJson(shopData);
        
        // Calculate distance if shop has location
        if (shop.hasLocation) {
          final distance = _calculateDistance(
            latitude, longitude,
            shop.latitude!, shop.longitude!
          );
          
          // Only include shops within the specified radius
          if (distance <= radiusKm) {
            uniqueShops[shop.id] = shop;
          }
        }
      }
      
      final shops = uniqueShops.values.toList();
      
      // Sort by distance
      shops.sort((a, b) {
        final distanceA = _calculateDistance(
          latitude, longitude,
          a.latitude!, a.longitude!
        );
        final distanceB = _calculateDistance(
          latitude, longitude,
          b.latitude!, b.longitude!
        );
        return distanceA.compareTo(distanceB);
      });
      
      print('DEBUG ShopService: Found ${shops.length} unique shops with product: $productName within ${radiusKm}km');
      return shops;
    } catch (e) {
      print('DEBUG ShopService: Error in searchShopsByProductAndLocation: $e');
      rethrow;
    }
  }

  // Get shops by location (within radius)
  Future<List<Shop>> getShopsByLocation({
    required double latitude,
    required double longitude,
    required double radiusKm,
  }) async {
    try {
      print('DEBUG ShopService: Getting shops near location ($latitude, $longitude) within ${radiusKm}km');
      
      // Get all shops that have location data
      final response = await _supabase
          .from('shops')
          .select()
          .not('latitude', 'is', null)
          .not('longitude', 'is', null);

      print('DEBUG ShopService: Raw location response: $response');
      
      final allShops = (response as List)
          .map((shop) => Shop.fromJson(shop))
          .toList();
      
      // Filter shops within radius and sort by distance
      final nearbyShops = <Shop>[];
      
      for (final shop in allShops) {
        if (shop.hasLocation) {
          final distance = _calculateDistance(
            latitude, longitude,
            shop.latitude!, shop.longitude!
          );
          
          if (distance <= radiusKm) {
            nearbyShops.add(shop);
          }
        }
      }
      
      // Sort by distance
      nearbyShops.sort((a, b) {
        final distanceA = _calculateDistance(
          latitude, longitude,
          a.latitude!, a.longitude!
        );
        final distanceB = _calculateDistance(
          latitude, longitude,
          b.latitude!, b.longitude!
        );
        return distanceA.compareTo(distanceB);
      });
      
      print('DEBUG ShopService: Found ${nearbyShops.length} shops within ${radiusKm}km');
      return nearbyShops;
    } catch (e) {
      print('DEBUG ShopService: Error in getShopsByLocation: $e');
      rethrow;
    }
  }

  // Calculate distance between two points using Haversine formula
  double _calculateDistance(double lat1, double lon1, double lat2, double lon2) {
    const double earthRadius = 6371; // Earth's radius in kilometers
    
    final double dLat = _degreesToRadians(lat2 - lat1);
    final double dLon = _degreesToRadians(lon2 - lon1);
    
    final double a = sin(dLat / 2) * sin(dLat / 2) +
        cos(_degreesToRadians(lat1)) * cos(_degreesToRadians(lat2)) *
        sin(dLon / 2) * sin(dLon / 2);
    
    final double c = 2 * atan2(sqrt(a), sqrt(1 - a));
    
    return earthRadius * c;
  }

  double _degreesToRadians(double degrees) {
    return degrees * (pi / 180);
  }

  // Calculate distance from user location to a specific shop
  double getDistanceToShop({
    required Shop shop,
    required double userLatitude,
    required double userLongitude,
  }) {
    if (!shop.hasLocation) {
      return double.infinity;
    }
    
    return _calculateDistance(
      userLatitude, userLongitude,
      shop.latitude!, shop.longitude!
    );
  }
}
